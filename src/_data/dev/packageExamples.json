{"all-named-html-entities":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  allNamedEntities,\n  allNamedEntitiesSetOnly,\n  allNamedEntitiesSetOnlyCaseInsensitive,\n  entStartsWith,\n  entEndsWith,\n  entStartsWithCaseInsensitive,\n  entEndsWithCaseInsensitive,\n  brokenNamedEntities,\n  decode,\n  minLength,\n  maxLength,\n  uncertain,\n&#x7D; from \"all-named-html-entities\";\n\nassert.equal(Object.keys(allNamedEntities).length, 2125);\nassert.equal(entStartsWith.A.E[0], \"AElig\");"}},"array-group-str-omit-num-char":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport groupStr from \"array-group-str-omit-num-char\";\n\nassert.deepEqual(groupStr([\"a1-1\", \"a2-2\", \"b3-3\", \"c4-4\"]), &#x7B;\n  \"a*-*\": 2,\n  \"b3-3\": 1,\n  \"c4-4\": 1,\n&#x7D;);"}},"array-includes-with-glob":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport includesWithGlob from \"array-includes-with-glob\";\n\nassert.equal(includesWithGlob([\"xc\", \"yc\", \"zc\"], \"*c\"), true);\n// (all 3)\n\nassert.equal(includesWithGlob([\"xc\", \"yc\", \"zc\"], \"*a\"), false);\n// (none found)\n\nassert.equal(includesWithGlob([\"something\", \"anything\", \"zzz\"], \"some*\"), true);\n// (1 hit)"}},"array-of-arrays-into-ast":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport generateAst from \"array-of-arrays-into-ast\";\n\nassert.deepEqual(generateAst([[1, 2, 3], [1, 2], [5]]), &#x7B;\n  1: [\n    &#x7B;\n      2: [\n        &#x7B;\n          3: [null],\n        &#x7D;,\n        null,\n      ],\n    &#x7D;,\n  ],\n  5: [null],\n&#x7D;);"}},"array-of-arrays-sort-by-col":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport sortBySubarray from \"array-of-arrays-sort-by-col\";\n\n// sort by second column, index number 1\nassert.deepEqual(sortBySubarray([[1, 9, 4], [1], [1, 9, 3], [1, 9, 2]], 1), [\n  [1, 9, 2],\n  [1, 9, 3],\n  [1, 9, 4],\n  [1],\n]);"}},"array-pull-all-with-glob":null,"arrayiffy-if-string":null,"ast-compare":null,"ast-contains-only-empty-space":null,"ast-deep-contains":null,"ast-delete-object":null,"ast-get-object":null,"ast-get-values-by-key":null,"ast-is-empty":null,"ast-loose-compare":null,"ast-monkey":null,"ast-monkey-traverse":{"_quickTake.js":{"title":"Extract paths of all object keys named \"foo\"","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport traverse from \"ast-monkey-traverse\";\n\nconst paths = [];\nconst source = &#x7B;\n  a: &#x7B;\n    foo: &#x7B;\n      bar: [\n        &#x7B;\n          foo: \"c\",\n        &#x7D;,\n      ],\n      d: &#x7B;\n        e: &#x7B;\n          foo: \"f\",\n        &#x7D;,\n      &#x7D;,\n    &#x7D;,\n  &#x7D;,\n&#x7D;;\n\ntraverse(source, (key, val, innerObj) => &#x7B;\n  // if currently an object is traversed, you get both \"key\" and \"val\"\n  // if it's array, only \"key\" is present, \"val\" is undefined\n  const current = val !== undefined ? val : key;\n  if (\n    // it's object (not array)\n    val !== undefined &&\n    // and has the key we need\n    key === \"foo\"\n  ) &#x7B;\n    // push the path to array in the outer scope\n    paths.push(innerObj.path);\n  &#x7D;\n  return current;\n&#x7D;);\n\n// notice object-path notation \"a.foo.bar.0.foo\" - array segments use dots too:\nassert.deepEqual(paths, [\"a.foo\", \"a.foo.bar.0.foo\", \"a.foo.d.e.foo\"]);"},"compatible-with-object-path.js":{"title":"Stop","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport op from \"object-path\";\nimport traverse from \"ast-monkey-traverse\";\n\nconst input = &#x7B; a: \"1\", b: [&#x7B; c: \"2\" &#x7D;] &#x7D;;\nObject.freeze(input); // let's freeze it, just for fun\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n&#x7D;);\n\n// notice the object-path notation is \"b.0.c\" not \"b[0].c\"\nassert.deepEqual(result1, [\"a\", \"b\", \"b.0\", \"b.0.c\"]);\n\n// each reported path is fully compatible with `object-path` get() method\nassert.deepEqual(op.get(input, \"a\"), \"1\");\nassert.deepEqual(op.get(input, \"b\"), [&#x7B; c: \"2\" &#x7D;]);\nassert.deepEqual(op.get(input, \"b.0\"), &#x7B; c: \"2\" &#x7D;);\nassert.deepEqual(op.get(input, \"b.0.c\"), \"2\");"},"stopping.js":{"title":"Stop","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport traverse from \"ast-monkey-traverse\";\n\nconst input = &#x7B; a: \"1\", b: &#x7B; c: \"2\" &#x7D; &#x7D;;\nconst result1 = [];\n\n// the full traversal would look like this:\ntraverse(input, (key1, val1, innerObj) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result1.push(innerObj.path);\n  return current;\n&#x7D;);\nassert.deepEqual(result1, [\"a\", \"b\", \"b.c\"]);\n\n// now let's stop the traversal at path \"b\" (that's real\n// path, how object-path would reference it)\nconst result2 = [];\ntraverse(input, (key1, val1, innerObj, stop) => &#x7B;\n  const current = val1 !== undefined ? val1 : key1;\n  result2.push(innerObj.path);\n  if (innerObj.path === \"b\") &#x7B;\n    stop.now = true; // <---------------- !!!!!!!!!!\n  &#x7D;\n  return current;\n&#x7D;);\nassert.deepEqual(result2, [\"a\", \"b\"]);"}},"ast-monkey-traverse-with-lookahead":null,"ast-monkey-util":null,"bitbucket-slug":null,"charcode-is-valid-xml-name-character":null,"check-types-mini":null,"chlu":null,"chlu-cli":null,"codsen-parser":null,"codsen-tokenizer":null,"color-shorthand-hex-to-six-digit":null,"csv-sort":null,"csv-sort-cli":null,"csv-split-easy":null,"detect-is-it-html-or-xhtml":null,"detergent":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; det, opts, version &#x7D; from \"detergent\";\n\n// on default setting, widow removal and encoding are enabled:\nassert.equal(det(\"clean this text Â£\").res, \"clean this text&nbsp;&pound;\");"}},"easy-replace":null,"edit-package-json":null,"email-all-chars-within-ascii":null,"email-all-chars-within-ascii-cli":null,"email-comb":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; comb, defaults, version &#x7D; from \"email-comb\";\n\n// aptly named classes:\nconst source = `<head>\n<style type=\"text/css\">\n.unused1[z] &#x7B;a:1;&#x7D;\n.used[z] &#x7B;a:2;&#x7D;\n</style>\n</head>\n<body class=\"  used  \"><a class=\"used unused3\">z</a>\n</body>\n`;\n\nconst intended = `<head>\n<style type=\"text/css\">\n.used[z] &#x7B;a:2;&#x7D;\n</style>\n</head>\n<body class=\"used\"><a class=\"used\">z</a>\n</body>\n`;\n\nassert.equal(comb(source).result, intended);"}},"email-homey":null,"emlint":null,"eslint-plugin-row-num":null,"eslint-plugin-test-num":null,"generate-atomic-css":null,"generate-atomic-css-cli":null,"gulp-email-remove-unused-css":null,"helga":null,"html-all-known-attributes":null,"html-crush":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; crush, defaults, version &#x7D; from \"html-crush\";\n\nassert.equal(\n  crush(\n    `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td>\n      hi\n    </td>\n  </tr>\n</table>`,\n    &#x7B; removeLineBreaks: true &#x7D;\n  ).result,\n  `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td> hi\n</td></tr></table>`\n);"}},"html-entities-not-email-friendly":null,"html-img-alt":null,"html-table-patcher":null,"is-char-suitable-for-html-attr-name":null,"is-html-attribute-closing":null,"is-html-tag-opening":null,"is-language-code":null,"is-media-descriptor":null,"is-relative-uri":null,"js-row-num":null,"js-row-num-cli":null,"json-comb":null,"json-comb-core":null,"json-sort-cli":null,"json-variables":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport jVar from \"json-variables\";\n\nassert.deepEqual(\n  jVar(&#x7B;\n    a: \"some text %%_var1.key1.0_%% more text %%_var2.key2.key3.1_%%\",\n    b: \"something\",\n    var1: &#x7B; key1: [\"value1\"] &#x7D;,\n    var2: &#x7B; key2: &#x7B; key3: [\"\", \"value2\"] &#x7D; &#x7D;,\n  &#x7D;),\n  &#x7B;\n    a: \"some text value1 more text value2\",\n    b: \"something\",\n    var1: &#x7B; key1: [\"value1\"] &#x7D;,\n    var2: &#x7B; key2: &#x7B; key3: [\"\", \"value2\"] &#x7D; &#x7D;,\n  &#x7D;\n);"}},"lect":null,"lerna-clean-changelogs":null,"lerna-clean-changelogs-cli":null,"lerna-link-dep":null,"object-all-values-equal-to":null,"object-boolean-combinations":null,"object-delete-key":null,"object-fill-missing-keys":null,"object-flatten-all-arrays":null,"object-flatten-referencing":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport ofr from \"object-flatten-referencing\";\n\nassert.deepEqual(\n  ofr(\n    &#x7B;\n      key1: \"val11.val12\",\n      key2: \"val21.val22\",\n    &#x7D;,\n    &#x7B;\n      key1: \"Contact us\",\n      key2: \"Tel. 0123456789\",\n    &#x7D;\n  ),\n  &#x7B;\n    key1: \"%%_val11.val12_%%\",\n    key2: \"%%_val21.val22_%%\",\n  &#x7D;\n);"}},"object-merge-advanced":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport mergeAdvanced from \"object-merge-advanced\";\n\nassert.deepEqual(\n  mergeAdvanced(\n    &#x7B;\n      a: [\"c\"],\n      m: \"n\",\n    &#x7D;,\n    &#x7B;\n      a: \"b\",\n      k: \"l\",\n    &#x7D;,\n    &#x7B;\n      ignoreKeys: [\"a\"],\n    &#x7D;\n  ),\n  &#x7B;\n    a: [\"c\"],\n    k: \"l\",\n    m: \"n\",\n  &#x7D;\n);"}},"object-no-new-keys":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport nnk from \"object-no-new-keys\";\n\nassert.deepEqual(\n  nnk(\n    &#x7B;\n      a: &#x7B;\n        b: \"b\",\n        c: \"c\",\n      &#x7D;,\n      x: \"y\",\n    &#x7D;,\n    &#x7B;\n      a: &#x7B;\n        c: \"z\",\n      &#x7D;,\n    &#x7D;\n  ),\n  [\"a.b\", \"x\"]\n);"}},"object-set-all-values-to":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport setAllValuesTo from \"object-set-all-values-to\";\n\nassert.deepEqual(\n  setAllValuesTo(&#x7B;\n    a: \"a\",\n    b: \"b\",\n    c: \"c\",\n    d: \"d\",\n  &#x7D;),\n  &#x7B;\n    a: false,\n    b: false,\n    c: false,\n    d: false,\n  &#x7D;\n);\n\n// you can change the default \"false\" to something else:\nassert.deepEqual(\n  setAllValuesTo(\n    &#x7B;\n      a: \"a\",\n      b: \"b\",\n      c: \"c\",\n      d: \"d\",\n    &#x7D;,\n    \"x\"\n  ),\n  &#x7B;\n    a: \"x\",\n    b: \"x\",\n    c: \"x\",\n    d: \"x\",\n  &#x7D;\n);"}},"ranges-apply":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport applyR from \"ranges-apply\";\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\nconst ranges = [\n  [4, 19, \"bad grey wolf\"],\n  [35, 43, \"little Red Riding Hood\"],\n];\nassert.equal(\n  applyR(oldString, ranges),\n  \"The bad grey wolf jumps over the little Red Riding Hood.\"\n);"}},"ranges-crop":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport crop from \"ranges-crop\";\n\nassert.deepEqual(\n  crop(\n    [\n      [2, 3],\n      [9, 10, \"bad grey wolf\"],\n      [1, 2],\n    ],\n    7\n  ),\n  [[1, 3]] // sorted, merged and cropped\n);"}},"ranges-ent-decode":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport decode from \"ranges-ent-decode\";\n\n// see codsen.com/ranges/\nassert.deepEqual(decode(\"a &#x26; b &amp; c\"), [\n  [2, 8, \"&\"], // <--- that's Ranges notation, instructing to replace\n  [11, 16, \"&\"],\n]);"}},"ranges-invert":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport invert from \"ranges-invert\";\n\nassert.deepEqual(\n  invert(\n    [\n      [3, 5],\n      [5, 7],\n    ],\n    9 // string length needed to set the boundary\n  ),\n  [\n    [0, 3],\n    [7, 9],\n  ]\n);"}},"ranges-is-index-within":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport isIndexWithin from \"ranges-is-index-within\";\n\nassert.equal(\n  isIndexWithin(8, [\n    [1, 2],\n    [5, 10],\n  ]),\n  true\n);\n\nassert.equal(\n  isIndexWithin(12, [\n    [1, 2],\n    [5, 10],\n  ]),\n  false\n);"}},"ranges-iterate":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport iterate from \"ranges-iterate\";\n\n// Ranges in the following example \"punches out\" a \"hole\" from `a` to `g`\n// (included), replacing it with `xyz`. That's what gets iterated.\n\nconst gathered = [];\n\n// a callback-based interface:\niterate(\"abcdefghij\", [[0, 7, \"xyz\"]], (&#x7B; i, val &#x7D;) => &#x7B;\n  gathered.push(`i = $&#x7B;i&#x7D;; val = $&#x7B;val&#x7D;`);\n&#x7D;);\n\nassert.deepEqual(gathered, [\n  \"i = 0; val = x\",\n  \"i = 1; val = y\",\n  \"i = 2; val = z\",\n  \"i = 3; val = h\",\n  \"i = 4; val = i\",\n  \"i = 5; val = j\",\n]);"}},"ranges-merge":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport mergeR from \"ranges-merge\";\n\n// joining edges:\nassert.deepEqual(\n  mergeR([\n    [1, 2],\n    [2, 3],\n    [9, 10],\n  ]),\n  [\n    [1, 3],\n    [9, 10],\n  ]\n);\n\n// an overlap:\nassert.deepEqual(\n  mergeR([\n    [1, 5],\n    [2, 10],\n  ]),\n  [[1, 10]]\n);"}},"ranges-process-outside":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport processOutside from \"ranges-process-outside\";\n\nconst gathered = [];\n\n// a callback interface:\nprocessOutside(\n  \"abcdefghij\",\n  [\n    [1, 5], // delete from \"b\" to \"f\"\n  ],\n  (fromIdx, toIdx, offsetValueCb) => &#x7B;\n    gathered.push(fromIdx);\n  &#x7D;\n);\n\nassert.deepEqual(gathered, [0, 5, 6, 7, 8, 9]);"}},"ranges-push":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport Ranges from \"ranges-push\";\nimport applyR from \"ranges-apply\";\n\nconst gatheredRanges = new Ranges();\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\n\n// push the ranges\ngatheredRanges.push(35, 43, \"little Red Riding Hood\");\ngatheredRanges.push(4, 19, \"bad grey wolf\");\n\n// retrieve the merged and sorted ranges by calling .current()\nassert.deepEqual(gatheredRanges.current(), [\n  [4, 19, \"bad grey wolf\"],\n  [35, 43, \"little Red Riding Hood\"],\n]);\n\nassert.equal(\n  applyR(oldString, gatheredRanges.current()),\n  \"The bad grey wolf jumps over the little Red Riding Hood.\"\n);\n\n// wipe all gathered ranges\ngatheredRanges.wipe();\nassert.equal(gatheredRanges.current(), null);"}},"ranges-regex":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport raReg from \"ranges-regex\";\n\nconst oldString = `The quick brown fox jumps over the lazy dog.`;\nconst result = raReg(/the/gi, oldString);\n\n// all regex matches, but in Ranges notation (see codsen.com/ranges/):\nassert.deepEqual(result, [\n  [0, 3],\n  [31, 34],\n]);\n\n// if you slice the ranges, you'll get original regex caught values:\nassert.deepEqual(\n  result.map(([from, to]) => oldString.slice(from, to)),\n  [\"The\", \"the\"]\n);"}},"ranges-sort":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport rsort from \"ranges-sort\";\n\n// Ranges (see codsen.com/ranges/) are sorted:\nassert.deepEqual(\n  rsort([\n    [2, 3],\n    [9, 10, \"bad grey wolf\"],\n    [1, 2],\n  ]),\n  [\n    [1, 2],\n    [2, 3],\n    [9, 10, \"bad grey wolf\"],\n  ]\n);"}},"regex-empty-conditional-comments":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport emptyCondCommentRegex from \"regex-empty-conditional-comments\";\n\n// empty comment which was meant to target Outlook-only\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]>\n<![endif]-->`),\n  true\n);\n\n// empty comment which was meant to target non-Outlook-only\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]><!-- -->\n<!--<![endif]-->`),\n  true\n);\n\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if !mso]><!-- -->\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n<!--<![endif]-->`),\n  false\n);\n\nassert.equal(\n  emptyCondCommentRegex().test(`<!--[if gte mso 9]><xml>\n<o:OfficeDocumentSettings>\n<o:AllowPNG/>\n<o:PixelsPerInch>96</o:PixelsPerInch>\n</o:OfficeDocumentSettings>\n</xml><![endif]-->`),\n  false\n);\n\nassert.equal(\n  emptyCondCommentRegex().exec(\"<html><!--[if !mso]><![endif]--><title>\")[0],\n  \"<!--[if !mso]><![endif]-->\"\n);\n\nassert.deepEqual(\n  `<html> <!--[if !mso]><![endif]--> <title>text</title> <!--[if gte mso 9]>\n<xml>\n<![endif]-->`.match(emptyCondCommentRegex()),\n  [\"<!--[if !mso]><![endif]-->\"]\n);"}},"str-indexes-of-plus":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport indx from \"str-indexes-of-plus\";\n\n// searches for string in a string, returns array:\nassert.deepEqual(indx(\"abc-abc-abc-abc\", \"abc\"), [0, 4, 8, 12]);\n\n// all graphemes are counted as one, emoji too:\nassert.deepEqual(\n  indx(\"ðŸ´-ðŸ¦„\", \"ðŸ¦„\"),\n  [2] // not [3] considering unicorn is 2-characters long\n);\n\n// you can offset the start of a search:\nassert.deepEqual(indx(\"abczabc\", \"abc\", 3), [4]);"}},"string-apostrophes":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; convertOne, convertAll &#x7D; from \"string-apostrophes\";\n\nassert.deepEqual(\n  convertAll(`In the '60s, rock 'n' roll`, &#x7B;\n    convertApostrophes: 1,\n    convertEntities: 0,\n  &#x7D;),\n  &#x7B;\n    result: \"In the â€™60s, rock â€™nâ€™ roll\",\n    ranges: [\n      [7, 8, \"â€™\"],\n      [18, 21, \"â€™nâ€™\"],\n    ],\n  &#x7D;\n);\n\nassert.deepEqual(\n  convertOne(`test's`, &#x7B;\n    from: 4,\n    to: 5,\n    convertApostrophes: true,\n    convertEntities: true,\n  &#x7D;),\n  [[4, 5, \"&rsquo;\"]]\n);"}},"string-character-is-astral-surrogate":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  isHighSurrogate,\n  isLowSurrogate,\n&#x7D; from \"string-character-is-astral-surrogate\";\n\n// ðŸ§¢ = \\uD83E\\uDDE2\n\nassert.equal(isHighSurrogate(\"\\uD83E\"), true);\n// the first character, high surrogate of the cap is indeed a high surrogate\n\nassert.equal(isHighSurrogate(\"\\uDDE2\"), false);\n// the second character, low surrogate of the cap is NOT a high surrogate\n\nassert.equal(isLowSurrogate(\"\\uD83E\"), false);\n// the first character, high surrogate of the cap is NOT a low surrogate\n// it's a high surrogate\n\nassert.equal(isLowSurrogate(\"\\uDDE2\"), true);\n// the second character, low surrogate of the cap is indeed a low surrogate"}},"string-collapse-leading-whitespace":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport collWhitespace from \"string-collapse-leading-whitespace\";\n\n// if leading/trailing whitespace doesn't contain \\n, collapse to a single space\nassert.equal(collWhitespace(\"  aaa   \"), \" aaa \");\n\n// otherwise, collapse to a single \\n (default setting)\nassert.equal(collWhitespace(\"     \\n\\n   aaa  \\n\\n\\n    \"), \"\\naaa\\n\");\n\n// does nothing to trimmed strings:\nassert.equal(collWhitespace(\"aaa\"), \"aaa\");\n\n// if there are multiple lines string is still processed in trim-fashion -\n// only beginning and ending whitespace is changed:\nassert.equal(\n  collWhitespace(\"  abc  \\n  def  \\n  ghi  \"),\n  \" abc  \\n  def  \\n  ghi \"\n);"}},"string-collapse-white-space":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport collapse from \"string-collapse-white-space\";\n\nassert.equal(collapse(\"  aaa     bbb    ccc   dddd  \"), \"aaa bbb ccc dddd\");\n\nassert.equal(collapse(\"   \\t\\t\\t   aaa   \\t\\t\\t   \"), \"aaa\");\n\nassert.equal(\n  collapse(\"   aaa   bbb  \\n    ccc   ddd   \", &#x7B; trimLines: false &#x7D;),\n  \"aaa bbb \\n ccc ddd\"\n);\n\nassert.equal(\n  collapse(\"   aaa   bbb  \\n    ccc   ddd   \", &#x7B; trimLines: true &#x7D;),\n  \"aaa bbb\\nccc ddd\"\n);\n\n// \\xa0 is an unencoded non-breaking space:\nassert.equal(\n  collapse(\n    \"     \\xa0    aaa   bbb    \\xa0    \\n     \\xa0     ccc   ddd   \\xa0   \",\n    &#x7B; trimLines: true, trimnbsp: true &#x7D;\n  ),\n  \"aaa bbb\\nccc ddd\"\n);"}},"string-convert-indexes":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  nativeToUnicode,\n  unicodeToNative,\n&#x7D; from \"string-convert-indexes\";\n\n// CONVERTING NATIVE JS INDEXES TO UNICODE-CHAR-COUNT-BASED\n// ðŒ† - \\uD834\\uDF06\n\n// at index 1, we have low surrogate, that's still grapheme index zero\nassert.equal(nativeToUnicode(\"\\uD834\\uDF06aa\", \"1\"), \"0\");\n// notice it's retained as string. The same type as input is retained!\n\n// at index 2, we have first letter a - that's second index, counting graphemes\nassert.equal(nativeToUnicode(\"\\uD834\\uDF06aa\", 3), 2);\n\n// convert many indexes at once - any nested data structure is fine:\nassert.deepEqual(nativeToUnicode(\"\\uD834\\uDF06aa\", [1, 0, 2, 3]), [0, 0, 1, 2]);\n\n// numbers from an AST-like complex structure are still picked out and converted:\nassert.deepEqual(nativeToUnicode(\"\\uD834\\uDF06aa\", [1, \"0\", [[[2]]], 3]), [\n  0, // notice matching type is retained\n  \"0\", // notice matching type is retained\n  [[[1]]],\n  2,\n]);\n\n// CONVERTING UNICODE-CHAR-COUNT-BASED TO NATIVE JS INDEXES\n// ðŒ† - \\uD834\\uDF06\n\nassert.deepEqual(unicodeToNative(\"\\uD834\\uDF06aa\", [0, 1, 2]), [0, 2, 3]);\n\nassert.deepEqual(unicodeToNative(\"\\uD834\\uDF06aa\", [1, 0, 2]), [2, 0, 3]);\n\nassert.throws(() => unicodeToNative(\"\\uD834\\uDF06aa\", [1, 0, 2, 3]));\n// throws an error!\n// that's because there's no character (counting Unicode characters) with index 3\n// we have only three Unicode characters, so indexes go only up until 2"}},"string-extract-class-names":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport extract from \"string-extract-class-names\";\n\n// extracts classes\nassert.deepEqual(extract(\"div.first-class.second-class\"), [\n  \".first-class\",\n  \".second-class\",\n]);\n\n// and id's\nassert.deepEqual(extract(\"div#brambles.gramples#croodles\"), [\n  \"#brambles\",\n  \".gramples\",\n  \"#croodles\",\n]);\n\n// optionally, you can request ranges (see codsen.com/ranges/):\nassert.deepEqual(extract(\"div.first-class.second-class\", true), [\n  [3, 15],\n  [15, 28],\n]);"},"contrived-complex.js":{"title":"Non-parsing algorithm can tackle really dodgy CSS","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport extract from \"string-extract-class-names\";\n\n// probably invalid input, but works anyway:\nassert.deepEqual(extract(\"?#id1#id2? #id3#id4> p > #id5#id6\"), [\n  \"#id1\",\n  \"#id2\",\n  \"#id3\",\n  \"#id4\",\n  \"#id5\",\n  \"#id6\",\n]);"},"with-space.js":{"title":"Processes whole CSS selectors","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport extract from \"string-extract-class-names\";\n\nassert.deepEqual(extract(\"div.first.second#third a[target=_blank]\"), [\n  \".first\",\n  \".second\",\n  \"#third\",\n]);"}},"string-extract-sass-vars":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport extractVars from \"string-extract-sass-vars\";\n\nassert.deepEqual(\n  extractVars(`// all variables are here!!!\n// ------------------------------------------\n$red: #ff6565; // this is red\n// $green: #63ffbd; // no green here\n$yellow: #ffff65; // this is yellow\n$blue: #08f0fd; // this is blue\n$fontfamily: Helvetica, sans-serif;\n$border: 1px solid #dedede;\n$borderroundedness: 3px;\n$customValue1: tralala;\n$customValue2: tralala;\n// don't mind this comment about #ff6565;\n$customValue3: 10;`),\n  &#x7B;\n    red: \"#ff6565\",\n    yellow: \"#ffff65\",\n    blue: \"#08f0fd\",\n    fontfamily: \"Helvetica, sans-serif\",\n    border: \"1px solid #dedede\",\n    borderroundedness: \"3px\",\n    customValue1: \"tralala\",\n    customValue2: \"tralala\",\n    customValue3: 10,\n  &#x7D;\n);"},"opts-cb.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport extractVars from \"string-extract-sass-vars\";\n// import \"color-shorthand-hex-to-six-digit\" to convert three-digit colour hex\n// codes to six-digit:\nimport conv from \"color-shorthand-hex-to-six-digit\";\n\nassert.deepEqual(\n  extractVars(\"$blue: #ccc;\", &#x7B;\n    throwIfEmpty: true,\n    cb: (val) => conv(val), // converts hex codes only, bypasses the rest\n  &#x7D;),\n  &#x7B; blue: \"#cccccc\" &#x7D;\n);"},"throw-if-empty.js":{"title":"Raise alarm if variables file has been wiped","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport extractVars from \"string-extract-sass-vars\";\n\nassert.throws(() =>\n  extractVars(\"\", &#x7B;\n    throwIfEmpty: true,\n  &#x7D;)\n);"}},"string-find-heads-tails":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport strFindHeadsTails from \"string-find-heads-tails\";\n\n// processing an arbitrary, custom templating markup:\nassert.deepEqual(\n  strFindHeadsTails(\n    \"some text %%_var1-%% more text %%_var2_%%\",\n    [\"%%_\", \"%%-\"], // two flavours of heads\n    [\"-%%\", \"_%%\"] // two flavours of tails\n  ),\n  [\n    &#x7B;\n      headsStartAt: 10,\n      headsEndAt: 13,\n      tailsStartAt: 17,\n      tailsEndAt: 20,\n    &#x7D;,\n    &#x7B;\n      headsStartAt: 31,\n      headsEndAt: 34,\n      tailsStartAt: 38,\n      tailsEndAt: 41,\n    &#x7D;,\n  ]\n);"}},"string-find-malformed":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport strFindMalformed from \"string-find-malformed\";\n\n// Below, we look for dodgy cases of `<!--`\nconst gathered = [];\nstrFindMalformed(\n  \"<div><!-something--></div>\",\n  \"<!--\",\n  // your callback function:\n  (obj) => &#x7B;\n    gathered.push(obj);\n  &#x7D;,\n  &#x7B;\n    maxDistance: 1, // Levenshtein distance\n  &#x7D;\n);\nassert.deepEqual(gathered, [\n  &#x7B;\n    idxFrom: 5,\n    idxTo: 8,\n  &#x7D;,\n]);"}},"string-fix-broken-named-entities":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport fixEnt from \"string-fix-broken-named-entities\";\nimport applyR from \"ranges-apply\";\n\nconst source = \"&nsp;x&nsp;y&nsp;\";\n\n// returns Ranges notation, see codsen.com/ranges/\nassert.deepEqual(fixEnt(source), [\n  [0, 5, \"&nbsp;\"],\n  [6, 11, \"&nbsp;\"],\n  [12, 17, \"&nbsp;\"],\n]);\n\n// render result from ranges using \"ranges-apply\":\nassert.equal(applyR(source, fixEnt(source)), \"&nbsp;x&nbsp;y&nbsp;\");"}},"string-left-right":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  left,\n  right,\n  leftSeq,\n  rightSeq,\n  chompLeft,\n  chompRight,\n  leftStopAtNewLines,\n  rightStopAtNewLines,\n&#x7D; from \"string-left-right\";\n\n// get the closest non-whitespace character to the left of \"d\" (which itself\n// is at string index 6)\nconst str = \"abc   def\";\n//             |   |\n//           012345678\n\nassert.equal(\n  `next non-whitespace character to the left of $&#x7B;str[6]&#x7D; (index 6) is $&#x7B;\n    str[left(str, 6)]\n  &#x7D; (index $&#x7B;left(str, 6)&#x7D;)`,\n  \"next non-whitespace character to the left of d (index 6) is c (index 2)\"\n);"}},"string-match-left-right":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  matchLeftIncl,\n  matchRightIncl,\n  matchLeft,\n  matchRight,\n&#x7D; from \"string-match-left-right\";\n\n// 3rd character is \"d\" because indexes start from zero.\n// We're checking the string to the left of it, \"bcd\", inclusive of current character (\"d\").\n// This means, \"bcd\" has to end with existing character and the other chars to the left\n// must match exactly:\nassert.equal(matchLeftIncl(\"abcdefghi\", 3, [\"bcd\"]), \"bcd\");\n\n// neither \"ab\" nor \"zz\" are to the left of 3rd index, \"d\":\nassert.equal(matchLeft(\"abcdefghi\", 3, [\"ab\", `zz`]), false);\n\n// \"def\" is to the right of 3rd index (including it), \"d\":\nassert.equal(matchRightIncl(\"abcdefghi\", 3, [\"def\", `zzz`]), \"def\");\n\n// One of values, \"ef\" is exactly to the right of 3rd index, \"d\":\nassert.equal(matchRight(\"abcdefghi\", 3, [\"ef\", `zz`]), \"ef\");"},"cb.js":{"title":"The Callback Use","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B;\n  matchLeftIncl,\n  matchRightIncl,\n  matchLeft,\n  matchRight,\n&#x7D; from \"string-match-left-right\";\n\n// imagine you looped the string and wanted to catch where does attribute \"class\" start\n// and end (not to mention to ensure that it's a real attribute, not something ending with this\n// string \"class\").\n// You catch \"=\", an index number 8.\n// This library can check, is \"class\" to the left of it and feed what's to the left of it\n// to your supplied callback function, which happens to be a checker \"is it a space\":\nfunction isSpace(char) &#x7B;\n  return typeof char === \"string\" && char.trim() === \"\";\n&#x7D;\n\nassert.equal(\n  matchLeft('<a class=\"something\">', 8, \"class\", &#x7B; cb: isSpace &#x7D;),\n  \"class\"\n);"}},"string-overlap-one-on-another":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport overlap from \"string-overlap-one-on-another\";\n\nassert.equal(overlap(\"aaa\", \"bbb\", &#x7B; offset: -2 &#x7D;), \"bbbaa\");"},"empty-str.js":{"title":"Empty Strings","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport overlap from \"string-overlap-one-on-another\";\n\nassert.equal(\n  overlap(\"\", \"456\", &#x7B; offset: 99, offsetFillerCharacter: \"zzzz\" &#x7D;),\n  \"456\"\n);\n// even though offset is long enough to warrant the filler, no characters\n// are added to the \"456\" because the first argument string is empty."}},"string-process-comma-separated":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport processCommaSeparated from \"string-process-comma-separated\";\n\nconst gatheredChunks = [];\nconst gatheredErrors = [];\nconst rawnbsp = \"\\u00a0\";\n\n// it's a callback-interface:\nprocessCommaSeparated(`<FRAMESET rows=\" ,,\\t50% ,$&#x7B;rawnbsp&#x7D; 50% ,\\t\\t,\">`, &#x7B;\n  from: 16, // <- beginning of the attribute's value\n  to: 35, // <- ending of the attribute's value\n  separator: \",\",\n  cb: (idxFrom, idxTo) => &#x7B;\n    gatheredChunks.push([idxFrom, idxTo]);\n  &#x7D;,\n  errCb: (ranges, message) => &#x7B;\n    gatheredErrors.push(&#x7B; ranges, message &#x7D;);\n  &#x7D;,\n&#x7D;);\n\nassert.deepEqual(gatheredChunks, [\n  [20, 23],\n  [27, 30],\n]);\n\nassert.deepEqual(gatheredErrors, [\n  &#x7B; ranges: [[16, 17]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[17, 18]], message: \"Remove separator.\" &#x7D;,\n  &#x7B; ranges: [[18, 19]], message: \"Remove separator.\" &#x7D;,\n  &#x7B; ranges: [[19, 20]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[23, 24]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[25, 27]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[30, 31]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[32, 34]], message: \"Remove whitespace.\" &#x7D;,\n  &#x7B; ranges: [[31, 32]], message: \"Remove separator.\" &#x7D;,\n  &#x7B; ranges: [[34, 35]], message: \"Remove separator.\" &#x7D;,\n]);"}},"string-range-expander":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport expander from \"string-range-expander\";\n\n// let's say we have picked the \"zzzz\" index range - [16, 20]\n// \"something>\\n\\t    zzzz <here\"\n//                    |   |\n//                  from  to\n//\n// PS. \"\\n\" and \"\\t\" take up a single character's length\n\nassert.deepEqual(\n  expander(&#x7B;\n    str: \"something>\\n\\t    zzzz <here\",\n    from: 16,\n    to: 20,\n    ifRightSideIncludesThisThenCropTightly: \"<\",\n  &#x7D;),\n  [10, 21]\n);"}},"string-remove-duplicate-heads-tails":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport removeDuplicateHeadsTails from \"string-remove-duplicate-heads-tails\";\n\nassert.equal(\n  removeDuplicateHeadsTails(\"&#x7B;&#x7B; Hi &#x7B;&#x7B; first_name &#x7D;&#x7D;! &#x7D;&#x7D;\", &#x7B;\n    heads: \"&#x7B;&#x7B; \",\n    tails: \" &#x7D;&#x7D;\",\n  &#x7D;),\n  \"Hi &#x7B;&#x7B; first_name &#x7D;&#x7D;!\"\n);"}},"string-remove-thousand-separators":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport remSep from \"string-remove-thousand-separators\";\n\n// ðŸ‡¬ðŸ‡§ ðŸ‡ºðŸ‡¸ thousand separators:\nassert.equal(remSep(\"1,000,000.00\"), \"1000000.00\");\n\n// ðŸ‡·ðŸ‡º  thousand separators:\nassert.equal(remSep(\"1 000 000,00\"), \"1000000,00\");\n// (if you want it converted to Western notation with dot,\n// set opts.forceUKStyle = true\n\n// ðŸ‡¨ðŸ‡­ thousand separators:\nassert.equal(remSep(\"1'000'000.00\"), \"1000000.00\");\n\n// IT'S SMART TOO:\n\n// will not delete if the thousand separators are mixed:\nconst input = \"100,000,000.000\";\nassert.equal(remSep(input), input);\n// ^ does nothing\n\n// but will remove empty space, even if there is no decimal separator:\n// (that's to cope with Russian notation integers that use thousand separators)\nassert.equal(remSep(\"100 000 000 000\"), \"100000000000\");\n\n// while removing thousand separators, it will also pad the digits to two decimal places\n// (optional, on by default, to turn it off set opts.padSingleDecimalPlaceNumbers to `false`):\nassert.equal(remSep(\"100,000.2\"), \"100000.20\");\nconsole.log();\n// ^ Western notation\n\nassert.equal(remSep(\"100 000,2\"), \"100000,20\");\n// ^ Russian notation\n\nassert.equal(remSep(\"100'000.2\"), \"100000.20\");\n// ^ Swiss notation"}},"string-remove-widows":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; removeWidows &#x7D; from \"string-remove-widows\";\n\nconst result = removeWidows(\"Some text with many words on one line.\");\n\n// time taken can vary so we'll set it to zero:\nresult.log.timeTakenInMiliseconds = 0;\n\nassert.deepEqual(result, &#x7B;\n  log: &#x7B;\n    timeTakenInMiliseconds: 0,\n  &#x7D;,\n  ranges: [[32, 33, \"&nbsp;\"]], // see codsen.com/ranges/\n  res: \"Some text with many words on one&nbsp;line.\",\n  whatWasDone: &#x7B;\n    convertEntities: false,\n    removeWidows: true,\n  &#x7D;,\n&#x7D;);"}},"string-split-by-whitespace":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport splitByW from \"string-split-by-whitespace\";\n\n// Split by whitespace is easy - use native String.prototype.split()\nassert.deepEqual(\"abc  def ghi\".split(/\\s+/), [\"abc\", \"def\", \"ghi\"]);\n\nconst source = `\\n     \\n    a\\t \\nb    \\n      \\t`;\n\n// this program is nearly equivalent to regex-based split:\nassert.deepEqual(source.split(/\\s+/), [\"\", \"a\", \"b\", \"\"]);\nassert.deepEqual(splitByW(source), [\"a\", \"b\"]);\n// regex-based split needs more filtration but it's native solution\n\n// ADDITIONALLY...\n\n// this program allows to exclude certain index ranges:\nassert.deepEqual(\n  splitByW(\"a b c d e\", &#x7B;\n    ignoreRanges: [[0, 2]], // that's \"a\" and space after it\n  &#x7D;),\n  [\"b\", \"c\", \"d\", \"e\"]\n);"}},"string-strip-html":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nassert.equal(\n  stripHtml(`Some text <b>and</b> text.`).result,\n  `Some text and text.`\n);\n\n// prevents accidental string concatenation\nassert.equal(stripHtml(`aaa<div>bbb</div>ccc`).result, `aaa bbb ccc`);\n\n// tag pairs with content, upon request\nassert.equal(\n  stripHtml(`a <pre><code>void a;</code></pre> b`, &#x7B;\n    stripTogetherWithTheirContents: [\n      \"script\", // default\n      \"style\", // default\n      \"xml\", // default\n      \"pre\", // <-- custom-added\n    ],\n  &#x7D;).result,\n  `a b`\n);\n\n// detects raw, legit brackets:\nassert.equal(stripHtml(`a < b and c > d`).result, `a < b and c > d`);"},"extract-html-head-contents.js":{"title":"Extract HTML head contents","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>\n  <body>\n    the content\n  </body>\n</html>`;\n\n// The task asks not to include <head...> and </head>.\n// First, extract head tag-to-head tag, including contents\nconst headWithHeadTags = stripHtml(someHtml, &#x7B;\n  onlyStripTags: [\"head\"],\n  stripTogetherWithTheirContents: [\"head\"],\n&#x7D;)\n  .filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  )\n  .trim();\n\nassert.equal(\n  headWithHeadTags,\n  `<head>\n    <meta charset=\"utf-8\">\n    <title>the title</title>\n  </head>`\n);\n\nconst headContents = headWithHeadTags.replace(/<\\/?head>/g, \"\").trim();\nassert.equal(\n  headContents,\n  `<meta charset=\"utf-8\">\n    <title>the title</title>`\n);"},"leave-only-html.js":{"title":"Leave only HTML","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(\n  stripHtml(someHtml).allTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<!DOCTYPE html><html lang=\"en\" dir=\"ltr\"><head><meta charset=\"utf-8\"><title></title></head><body><h1></h1></body></html>`\n);"},"leave-only-opening-td.js":{"title":"Leave only opening td tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\n// the first way\n// -----------------------------------------------------------------------------\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    // notice there's no: onlyStripTags: [\"td\"]\n    // we operate purely via callback\n    cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n      if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n        rangesArr.push(proposedReturn);\n      &#x7D;\n    &#x7D;,\n  &#x7D;).ranges.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to).trim()&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);\n\n// the second way:\n// -----------------------------------------------------------------------------\n\nlet resultStr = \"\";\n// notice we don't even assign stripHtml() output to anything - we rely only\n// on the callback, it mutates the \"resultStr\" in the upper scope\nstripHtml(someHtml, &#x7B;\n  // notice there's no: onlyStripTags: [\"td\"]\n  // we operate purely via callback\n  cb: (&#x7B; tag, deleteFrom, deleteTo, insert, rangesArr, proposedReturn &#x7D;) => &#x7B;\n    if (tag.name === \"td\" && !tag.slashPresent) &#x7B;\n      resultStr += someHtml.slice(deleteFrom, deleteTo).trim();\n    &#x7D;\n  &#x7D;,\n&#x7D;);\nassert.equal(\n  resultStr,\n  `<td class=\"col1\"><td class=\"col2\"><td class=\"col3\"><td class=\"col4\">`\n);"},"leave-only-td.js":{"title":"Leave only td tags","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<table width=\"100\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n  <tr>\n    <td class=\"col1\">\n      cell1\n    </td>\n    <td class=\"col2\">\n      cell2\n    </td>\n  </tr>\n  <tr>\n    <td class=\"col3\">\n      cell3\n    </td>\n    <td class=\"col4\">\n      cell4\n    </td>\n  </tr>\n</table>`;\n\nassert.equal(\n  stripHtml(someHtml, &#x7B;\n    onlyStripTags: [\"td\"],\n  &#x7D;).filteredTagLocations.reduce(\n    (acc, [from, to]) => `$&#x7B;acc&#x7D;$&#x7B;someHtml.slice(from, to)&#x7D;`,\n    \"\"\n  ),\n  `<td class=\"col1\"></td><td class=\"col2\"></td><td class=\"col3\"></td><td class=\"col4\"></td>`\n);"},"remove-html.js":{"title":"Remove all HTML from a string","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport stripHtml from \"string-strip-html\";\n\nconst someHtml = `<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title></title>\n  </head>\n  <body>\n    <h1>Title</h1>\n    Some text.\n  </body>\n</html>`;\n\nassert.equal(stripHtml(someHtml).result, `Title\\nSome text.`);"}},"string-trim-spaces-only":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport trimSpaces from \"string-trim-spaces-only\";\n\nassert.deepEqual(trimSpaces(\"  aaa   \"), &#x7B;\n  res: \"aaa\",\n  ranges: [\n    [0, 2],\n    [5, 8],\n  ],\n&#x7D;);\n\nassert.deepEqual(trimSpaces(\"   \\t  zz   \\n    \"), &#x7B;\n  res: \"\\t  zz   \\n\",\n  ranges: [\n    [0, 3],\n    [12, 16],\n  ],\n&#x7D;);"}},"string-uglify":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; uglifyById, uglifyArr, version &#x7D; from \"string-uglify\";\n\n// notice we put dots and hashes for classes and id's but algorithm will work\n// fine too if you won't.\nconst names = [\n  \".module-promo-all\",\n  \".module-promo-main\",\n  \".module-promo-second\",\n  \"#zzz\",\n];\n\n// notice we put dots and hashes for classes and id's but algorithm will work\n// fine too if you won't.\nassert.deepEqual(uglifyArr(names), [\".o\", \".s\", \".z\", \"#l\"]);\n\n// uglify a particular id number:\nassert.equal(uglifyById(names, 3), \"#l\");"}},"string-unfancy":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport unfancy from \"string-unfancy\";\n\n// U+2019\n// https://www.fileformat.info/info/unicode/char/2019/index.htm\n// https://mothereff.in/js-escapes\nconst rightSingleQuote = \"\\u2019\";\n\nassert.equal(unfancy(`someone$&#x7B;rightSingleQuote&#x7D;s`), \"someone's\");\n\n// works with encoded HTML:\nassert.equal(unfancy(\"someone&rsquo;s\"), \"someone's\");"}},"tap-parse-string-to-object":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport parseRawTap from \"tap-parse-string-to-object\";\n\n// synchronous parsing (there's also async, see in examples)\nassert.deepEqual(\n  parseRawTap(`TAP version 13\nok 1 - test/test.js # time=22.582ms &#x7B; # Subtest: 01.01 - string input\nok 1 - 01.01.01\nok 2 - 01.01.02\n1..2\nok 1 - 01.01 - string input # time=7.697ms\n\n # Subtest: 01.02 - non-string input\nok 1 - 01.02.01\nok 2 - 01.02.02\nok 3 - 01.02.03\nok 4 - 01.02.04\nok 5 - 01.02.05\n1..5\nok 2 - 01.02 - non-string input # time=2.791ms\n\n 1..2 # time=22.582ms\n&#x7D;\n\nok 2 - test/umd-test.js # time=16.522ms &#x7B; # Subtest: UMD build works fine\nok 1 - should be equivalent\n1..1\nok 1 - UMD build works fine # time=10.033ms\n\n 1..1 # time=16.522ms\n&#x7D;\n\n1..2\n\n# time=1816.082ms\n`),\n  &#x7B;\n    ok: true,\n    assertsTotal: 8,\n    assertsPassed: 8,\n    assertsFailed: 0,\n    suitesTotal: 2,\n    suitesPassed: 2,\n    suitesFailed: 0,\n  &#x7D;\n);"}},"update-versions":null,"util-array-object-or-both":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport arrObjOrBoth from \"util-array-object-or-both\";\n\n// normalises string, a user preference:\n\nassert.equal(arrObjOrBoth(\"arrays\"), \"array\");\nassert.equal(arrObjOrBoth(\"array\"), \"array\");\nassert.equal(arrObjOrBoth(\"arr\"), \"array\");\nassert.equal(arrObjOrBoth(\"a\"), \"array\");\n\nassert.equal(arrObjOrBoth(\"objects\"), \"object\");\nassert.equal(arrObjOrBoth(\"object\"), \"object\");\nassert.equal(arrObjOrBoth(\"obj\"), \"object\");\nassert.equal(arrObjOrBoth(\"o\"), \"object\");\n\nassert.equal(arrObjOrBoth(\"whatever\"), \"any\");\nassert.equal(arrObjOrBoth(\"either\"), \"any\");\nassert.equal(arrObjOrBoth(\"both\"), \"any\");\nassert.equal(arrObjOrBoth(\"any\"), \"any\");\nassert.equal(arrObjOrBoth(\"all\"), \"any\");\nassert.equal(arrObjOrBoth(\"e\"), \"any\");"}},"util-nonempty":{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport nonEmpty from \"util-nonempty\";\n\nassert.equal(nonEmpty(\"z\"), true);\nassert.equal(nonEmpty(\"\"), false);\nassert.equal(nonEmpty([\"a\"]), true);\nassert.equal(nonEmpty([123]), true);\nassert.equal(nonEmpty([[[[[[[[[[[]]]]]]]]]]]), true);\nassert.equal(nonEmpty(&#x7B; a: \"\" &#x7D;), true);\nassert.equal(nonEmpty(&#x7B; a: \"a\" &#x7D;), true);\nassert.equal(nonEmpty(&#x7B;&#x7D;), false);\n\nconst f = () => &#x7B;\n  return \"z\";\n&#x7D;;\nassert.equal(nonEmpty(f), false);\n// (answer is instantly false if input is not array, plain object or string)"}}}